**A bunch of words and other stuff that will help naming stuff while programming. 
The aim of this file is to include words that actually appear in code and carry 
a very distinct and well-defined meaning, so that the next time you think to 
yourself 'damn, what is the word I should use in this function name / file name / variable name??' - you'll have a place to look...**

**Free-hand words that CAN be used:**
* A
  * Accept
  * Access
  * Accumulate / Accumulator
  * Acknowledge
  * Active / Activate
  * Adapt
  * Adjust
  * Agent
  * Agnostic
  * All
  * Allocate
  * Allow
  * Always
  * Anscestor
  * Annotate / Annotation
  * Any
  * Apply / Applying / Applier
  * Approve
  * Aspect
  * Associate
  * Async
  * Attach
  * Attack
* B
  * Backoff
  * Backoffice
  * Backpressue
  * Backward
  * Binary
  * Bind
  * Bounce
  * Break
  * Breakdown
  * Bridge
  * Broker
  * Bucket
  * Buffer
  * Build
  * Burst
* C
  * Cache
  * Call
  * Callback
  * Cancel
  * Catch
  * Category
  * Character
  * Child
  * Clear
  * Client
  * Clone
  * Close
  * Code / Response Code
  * Coherent
  * Collector / Collection
  * Combination
  * Commit
  * Compact
  * Compatibility
  * Compile
  * Complete
  * Complexity / Complex
  * Compose
  * Compress
  * Comupte
  * Concrete
  * Concurrent / Concurrency
  * Condition / Conditinal
  * Configure / Configuration
  * Conflict
  * Connect / Connector
  * Consecutive
  * Consistent / Consistency
  * Construct / Constructor
  * Container / Contains
  * Context
  * Continuation
  * Controll / Controller
  * Copy
  * Correct
  * Corrupt
  * Count / Counter
  * Coverage
  * Create
  * Cross
  * Cycle
* D
  * Date
  * Deactivate
  * Decrypt
  * Deduce
  * Default
  * Defer
  * Deflect
  * Degrade
  * Delegate
  * Delete
  * Deny
  * Dependency
  * Deploy
  * Dequeue
  * Derive / Derivative
  * Descriptor
  * Deserialize
  * Destroy
  * Destruct
  * Detach
  * Detect / Detector / Detection
  * Diagnose
  * Diffrentiate
  * Direction
  * Disconnect
  * Distinct
  * Distribute / Distribution
  * Document
  * Domain
  * Downgrade
  * Downstream
  * Driver
  * Drop
  * Duplicate
* E
  * Effective
  * Efficient
  * Elapse
  * Election
  * Encrypt
  * End2End
  * Enforce / Enforcer
  * Engine
  * Enqueue
  * Enrich
  * Enumerator / Enumeration
  * Ephemeral
  * Error
  * Establish
  * Evaluate
  * Event
  * Event Loop
  * Eventual
  * Evict
  * Execution / Execution Context
  * Exists
  * Experiment
  * Expiry / Expiration
  * Exponential
  * Expose
  * Expression
* F
  * Facade
  * Factory
  * Fail / Failure
  * Fallback
  * Fence
  * Filter
  * First
  * Find
  * Flavour
  * Flow
  * Fluent
  * Flush
  * Fold
  * Format
  * Forward
* G
  * Gate / Gateway
  * Gradual
  * Granting / Granter
  * Graph
  * Group
  * Guide / Guidance
* H
  * Handler
  * Handshake
  * Head
  * Hold
  * Hook
* I
  * Identity
  * Ignore
  * Illegal
  * Immutable
  * Incoming
  * Index / Indexing
  * Inflate
  * Ingest
  * Init / Initialize
  * Inject
  * Insert
  * Install
  * Instance
  * Integration / Integrator
  * Intercept
  * Interface
  * Interpreter / Interpret
  * Interval
  * Iterate / Iterator
* J
* K
* L
  * Last
  * Leader
  * Lease
  * Legal
  * Lifecycle
  * Limit / Limiter
  * Linear
  * Load
  * Lock
  * Log
  * Loop
* M
  * Magnitude
  * Map
  * Marshall
  * Match / Matcher
  * Materialized View
  * Measure
  * Metric
  * Migrate
  * Model
  * Modifier
  * Mutable
* N
  * Neglect / Negligible
  * Never
  * Next
  * Node
  * None
* O
  * Offload
  * On-demand
  * Open
  * Option
  * Orchestrator / Orchestration  
  * Order
  * Orient / Orientation
  * Orphan
  * Orthogonal
  * Outgoing
* P
  * Parallel
  * Parse
  * Path
  * Pattern
  * Peek
  * Pending
  * Penetrate
  * Permission
  * Permutation
  * Persistent
  * Pick
  * Piggyback
  * Pipeline
  * Plugin
  * Policy
  * Poll
  * Pool
  * Populate
  * Predessesor
  * Predicate
  * Preemptive
  * Present
  * Pressure
  * Previous
  * Primitive
  * Process
  * Protocol
  * Proxy
  * Publish
  * Pull
  * Push
* Q
  * Queue
* R
  * Random
  * Random / Randomize
  * Range
  * Rate
  * React / Reactive
  * Read
  * Record
  * Recover
  * Reduce
  * Refresh
  * Register
  * Regression
  * Reject
  * Release
  * Reliable
  * Remove
  * Report
  * Repository
  * Represent / Representation
  * Request
  * Reserve
  * Reset
  * Residual
  * Resolver
  * Respond
  * Response
  * Restore
  * Retrieve
  * Reverse
  * Review
  * Rollback
  * Rollout
  * Rule
* S
  * Scavenge / Scavenger
  * Schedule
  * Scope
  * Search
  * Selector
  * Send
  * Serialize
  * Server
  * Ship
  * Shred
  * Sign / Signature
  * Singleton
  * Smooth
  * Some
  * Sort / Sorting / Sorter
  * Span
  * Sparse
  * Specific
  * Split
  * Stack / Stacktrace
  * Stage
  * State
  * Status
  * Strategy
  * Stream
  * Strong
  * Success
  * Suppress
  * Surface
  * Sync / Synchronize / Synchronization
* T
  * Tail
  * Teardown
  * Terminate / Termination
  * Test
  * Thread
  * Time / Timer
  * Token
  * Topology
  * Trace
  * Traffic
  * Transaction
  * Transform
  * Transient
  * Translate
  * Transparent
  * Transpile
  * Traverse
  * Type
* U
  * Underlying
  * Uniform
  * Unique
  * Unload
  * Unmarshal
  * Unrecoverable
  * Update
  * Upgrade
  * Upstream
  * User
  * Unwind
* V
  * Validation / Validator / Valid
  * Version
  * Vertex
  * Virtual
  * Visibility
  * Visitor
  * View
* W
  * Wait
  * Warning
  * Watchdog
  * Weak
  * Workflow
  * Workload
  * Wrap
  * Write
* X
* Y
* Z
  * Zombie

**Words that should never be used (the word and all its derivatives):**
* Manager
* Utility
* Helper
* Impl
* Internal

**Other wisdom**:
* The type of a variable should not affect its name. The name of a variable should reflect the meaning and intention of the variable in the current scope. If a variable represents the amount of tax we need to add to a given price, why should its name include the type of the variable? This extra information about the variable is a waste, a cognitive load we must avoid.
* One of the most important goals of proper naming, is to reduce - as much as possible - the cognitive load on the programmer. A name should accurately and concisely express the intention and meaning of a variable, without adding anything else that is irrelevant. 
* A good name requires very little from the programmer in terms of storing state in the programmer's short-term memory (which is painfully small) when reading the code and making sense of it.
